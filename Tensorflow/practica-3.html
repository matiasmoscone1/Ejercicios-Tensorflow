<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js"></script>
    <title>Document</title>
</head>
<body>
    
    <script>
    /* 
    
    /*Regresión lineal simple

    Objetivo:
    Entrenar un modelo que aprenda la función lineal:

        y = 2x+1

    Indicaciones:

        Crea un modelo secuencial.

        Agrega una sola capa densa con units: 1 y inputShape: [1].

    Compila el modelo con:

        optimizer: 'sgd'
        loss: 'meanSquaredError'

    Entrena el modelo con valores:

        const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);
        const ys = tf.tensor2d([3, 5, 7, 9], [4, 1]);
    
        Una vez entrenado, haz una predicción para x = 5.
    El resultado debería acercarse a 11.

*/

        /* EJERCICIO BONUS */

        const predictFunction = async () => {
            const model = tf.sequential();

            //capa 1
            model.add(tf.layers.dense({units: 1, inputShape: [1]}));

            model.compile({
                optimizer: "sgd",
                loss: "meanSquaredError"
            });

            const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);
            const ys = tf.tensor2d([3, 5, 7, 9], [4, 1]);


            await model.fit(xs, ys, {
                batchSize: 4,
                epochs: 300,
                callbacks: {
                    onEpochEnd: (epoch, logs) => {
                        console.log(`Epoca: ${epoch + 1}: - Perdida: ${logs.loss}`);
                    }
                }
            });

            tf.tidy(() => {
                const output = model.predict(tf.tensor2d([5], [1, 1]));

                //output.print();

                output.array().then((num) => {
                    console.log(num[0][0]);
                });
            })

            //para saber cuantos parametros hay en cada capa
            //model.summary();

        }

        //predictFunction();


        //para saber que backend esta usando tensorflow: (cpu o webgl o wasm)
        //console.log(tf.getBackend());
        

        /* EJERCICIO 2 (MODELOS) */
    
        //Regresión múltiple:
            //Predecir el precio de una casa usando metros² y cantidad de habitaciones.

            //entrada = metros cuadrados (50, 100, 80)
            //entrada = habitaciones (1, 2, 3, 4)
            //salida = precio
        
            //y = metros² * 10  +  habitaciones * 50  +  20
   
        const ejercicio_2 = async () => {
        
            const model = tf.sequential();

            //layer 1
            
            model.add(tf.layers.dense({units: 1, inputShape: [2]}));

            model.compile({
                optimizer: tf.train.sgd(0.01),
                loss: "meanSquaredError"
            });
            
            /*
            const xs = tf.tensor2d([[30/120, 1/6], [50/120, 2/6], [70/120, 3/6], [90/120, 4/6]], [4, 2]);

            const ys = tf.tensor2d([[370/1200], [620/1200], [870/1200], [1120/1200]], [4, 1]);
            */
            const xs = tf.tensor2d([
                [30/120, 1/6],
                [35/120, 1/6],
                [40/120, 2/6],
                [45/120, 2/6],
                [50/120, 2/6],
                [55/120, 3/6],
                [60/120, 3/6],
                [65/120, 3/6],
                [70/120, 4/6],
                [75/120, 4/6],
                [80/120, 4/6],
                [85/120, 5/6],
                [90/120, 5/6],
                [95/120, 5/6],
                [100/120, 6/6],
                [105/120, 6/6],
                [110/120, 6/6],
                [115/120, 6/6],
                [120/120, 6/6],
                [118/120, 5/6],
            ], [20, 2]);

            const ys = tf.tensor2d([
                [350/2000],
                [380/2000],
                [450/2000],
                [500/2000],
                [600/2000],
                [650/2000],
                [700/2000],
                [750/2000],
                [800/2000],
                [850/2000],
                [900/2000],
                [1000/2000],
                [1100/2000],
                [1200/2000],
                [1300/2000],
                [1400/2000],
                [1500/2000],
                [1600/2000],
                [1700/2000],
                [1550/2000],
            ], [20, 1]);


            await model.fit(xs, ys, {
                batchSize: 20,
                epochs: 200,
                callbacks: {
                    onEpochEnd: (epoch, logs) => {
                        console.log(`Epoca: ${epoch + 1} - Perdida: ${logs.loss}`);
                    }
                }
            });

            
            tf.tidy(() => {
                const output = model.predict(tf.tensor2d([113/120, 6/6], [1, 2]));

                output.array().then((num) => {
                    console.log(num[0][0] * 2000);
                });

            });

        }


        //ejercicio_2();


        /* Clasificación binaria básica:
        Entrenar un modelo para clasificar si un número es mayor o menor que 5. */


        const ejercicio_3 = async () => {
        
            const model = tf.sequential();

            //layer 1
            model.add(tf.layers.dense({units: 1, inputShape:[1]}));

            model.compile({
                optimizer: "sgd",
                loss: "meanSquaredError"
            });

            const xs = tf.tensor2d([1, 2, 3, 4, 5, 6, 7, 8], [8, 1]);
            const ys = tf.tensor2d([0, 0, 0, 0, 0, 1, 1, 1], [8, 1]);

            
            await model.fit(xs, ys, {
                batchSize: 8,
                epochs: 100,
                callbacks: {
                    onEpochEnd: (epoch, log) => {
                        console.log(`Epoca: ${epoch + 1} - Perdida: ${log.loss}`)
                    }
                }
            });

            tf.tidy(() => {
                const output = model.predict(tf.tensor2d([4.9], [1, 1]));

                output.array().then((num) => {
                    console.log(num[0][0]);
                });
            });

        }

        //ejercicio_3();

        /* Clasificación con sigmoid:
                Crear un modelo que prediga si un estudiante aprueba (nota ≥ 60) según 
                horas de estudio. */

        
        const ejercicio_4 = async () => {

            const model = tf.sequential();

            //layer 1
            model.add(tf.layers.dense({units: 1, inputShape: [1], activation: "sigmoid"}));

            model.compile({
                optimizer: "sgd",
                loss: "meanSquaredError"
            });

            const xs = tf.tensor2d([1, 2, 4, 5, 10, 20, 30], [7, 1]);
            const ys = tf.tensor2d([0, 0, 0, 0, 1, 1, 1], [7, 1]);

            await model.fit(xs, ys, {
                batchSize: 7,
                epochs: 100,
                callbacks: {
                    onEpochEnd: (epoch, log) => {
                        console.log(`Epoca: ${epoch + 1} - Perdida: ${log.loss}`);
                    }
                }
            });

            tf.tidy(() => {
                const output = model.predict(tf.tensor2d([20], [1,1]));

                output.array().then((num) => {
                    console.log(num[0][0]);
                })
            });
        }

        //ejercicio_4();


    /*  Predicción con varios features:
            Entrenar un modelo para predecir la temperatura usando hora del día y humedad. */

            /*
        const ejercicio_5 = async () => {

            const model = tf.sequential();

            //layer 1
            model.add(tf.layers.dense({units: 1, inputShape: [2]}));

            model.compile({
                optimizer: tf.train.sgd(0.001),
                loss: "meanSquaredError"
            });

            const xs = tf.tensor2d([
                [0/100, 45/100],
                [5/100, 40/100],
                [10/100, 55/100],
                [13/100, 65/100],
                [17/100, 75/100],
                [20/100, 90/100]
            ], [6, 2]);

            const ys = tf.tensor2d([18/100, 12/100, 22/100, 30/100, 35/100, 32/100], [6, 1]);

            await model.fit(xs, ys, {
                batchSize: 6,
                epochs: 100,
                callbacks: {
                    onEpochEnd: (epoch, log) => {
                        console.log(`Epoch: ${epoch + 1} - Perdida: ${log.loss}`);
                    }
                }
            });

            tf.tidy(() => {
                const output = model.predict(tf.tensor2d([14/100, 70/100], [1, 2]));

                output.array().then((num) => {
                    console.log(num[0][0] * 100);
                });
            });


        }

        ejercicio_5();*/

        const ejercicio_temp = async () => {

                // ------------------------------
                // 1) Datos reales simulados
                // ------------------------------
                const datosX = [
                    [3, 80],
                    [6, 75],
                    [9, 60],
                    [12, 50],
                    [15, 45],
                    [18, 55],
                    [21, 65]
                ];

                const datosY = [12, 15, 20, 27, 29, 24, 18];


                // ------------------------------
                // 2) Normalización
                // ------------------------------
                const normalizar = (arr) => {
                    const min = Math.min(...arr);
                    const max = Math.max(...arr);
                    return {
                        normalizados: arr.map(x => (x - min) / (max - min)),
                        min,
                        max
                    };
                };

                const hora = datosX.map(v => v[0]);
                const humedad = datosX.map(v => v[1]);

                const normHora = normalizar(hora);
                const normHum = normalizar(humedad);
                const normTemp = normalizar(datosY);

                const xs = tf.tensor2d(
                    datosX.map((_, i) => [
                        normHora.normalizados[i],
                        normHum.normalizados[i]
                    ])
                );

                const ys = tf.tensor2d(normTemp.normalizados, [datosY.length, 1]);


                // ------------------------------
                // 3) Modelo
                // ------------------------------
                const model = tf.sequential();

                model.add(tf.layers.dense({
                    units: 1,
                    inputShape: [2]
                }));

                model.compile({
                    optimizer: tf.train.adam(0.01),
                    loss: "meanSquaredError"
                });


                // ------------------------------
                // 4) Entrenamiento
                // ------------------------------
                await model.fit(xs, ys, {
                    epochs: 400,
                    batchSize: datosX.length,
                    callbacks: {
                        onEpochEnd: (epoch, log) => {
                            if ((epoch + 1) % 50 === 0) {
                                console.log(`Epoch ${epoch + 1} - Loss: ${log.loss}`);
                            }
                        }
                    }
                });


                // ------------------------------
                // 5) Predicción (ejemplo: 14hs con 55% humedad)
                // ------------------------------

                const entrada = [14, 40]; // Ejemplo realista

                const entradaNorm = [
                    (entrada[0] - normHora.min) / (normHora.max - normHora.min),
                    (entrada[1] - normHum.min) / (normHum.max - normHum.min)
                ];

                const pred = model.predict(tf.tensor2d([entradaNorm], [1, 2]));
                const valorNorm = (await pred.array())[0][0];

                const temperaturaFinal =
                    valorNorm * (normTemp.max - normTemp.min) + normTemp.min;

                console.log("Predicción normalizada:", valorNorm);
                console.log("Temperatura estimada:", temperaturaFinal.toFixed(2), "°C");

                };

            //ejercicio_temp();

              
/*  Clasificación multiclase:
        Clasificar flores del dataset Iris usando 4 características 
        (sepalLength, sepalWidth, petalLength, petalWidth). 
        
        Input p/ predecir: 
        Categorias de flores: (Setosa, Versicolor o Virginica)
        */

        
    const data =[
        {
        "sepalLength": 5.1,
        "sepalWidth": 3.5,
        "petalLength": 1.4,
        "petalWidth": 0.2,
        "species": "setosa"
        },
        {
        "sepalLength": 4.9,
        "sepalWidth": 3,
        "petalLength": 1.4,
        "petalWidth": 0.2,
        "species": "setosa"
        },
        {
        "sepalLength": 4.7,
        "sepalWidth": 3.2,
        "petalLength": 1.3,
        "petalWidth": 0.2,
        "species": "setosa"
        },
        {
        "sepalLength": 5.7,
        "sepalWidth": 3.8,
        "petalLength": 1.7,
        "petalWidth": 0.3,
        "species": "setosa"
        },
        {
        "sepalLength": 4.6,
        "sepalWidth": 3.1,
        "petalLength": 1.5,
        "petalWidth": 0.2,
        "species": "setosa"
        },
        {
        "sepalLength": 5.2,
        "sepalWidth": 2.7,
        "petalLength": 3.9,
        "petalWidth": 1.4,
        "species": "versicolor"
        },
        {
        "sepalLength": 5,
        "sepalWidth": 2,
        "petalLength": 3.5,
        "petalWidth": 1,
        "species": "versicolor"
        },
        {
        "sepalLength": 5.9,
        "sepalWidth": 3,
        "petalLength": 4.2,
        "petalWidth": 1.5,
        "species": "versicolor"
        },
        {
        "sepalLength": 5.5,
        "sepalWidth": 2.4,
        "petalLength": 3.8,
        "petalWidth": 1.1,
        "species": "versicolor"
        },
        {
        "sepalLength": 6,
        "sepalWidth": 2.2,
        "petalLength": 4,
        "petalWidth": 1,
        "species": "versicolor"
        }, 
        {"sepalLength": 6.4,
        "sepalWidth": 3.1,
        "petalLength": 5.5,
        "petalWidth": 1.8,
        "species": "virginica"
        },
        {
        "sepalLength": 6,
        "sepalWidth": 3,
        "petalLength": 4.8,
        "petalWidth": 1.8,
        "species": "virginica"
        },
        {
        "sepalLength": 6.9,
        "sepalWidth": 3.1,
        "petalLength": 5.4,
        "petalWidth": 2.1,
        "species": "virginica"
        },
        {
        "sepalLength": 6.7,
        "sepalWidth": 3.1,
        "petalLength": 5.6,
        "petalWidth": 2.4,
        "species": "virginica"
        },
        {
        "sepalLength": 6.9,
        "sepalWidth": 3.1,
        "petalLength": 5.1,
        "petalWidth": 2.3,
        "species": "virginica"
        }
    ];

    const dataY = [
        "setosa", "setosa", "setosa", "setosa", "setosa",
        "versicolor", "versicolor", "versicolor", "versicolor", "versicolor",
        "virginica", "virginica", "virginica", "virginica", "virginica"
    ];

    const normalizeDataset = (arr) => {
        const newArray = [];

        arr.map((obj) => {
            newArray.push([obj.sepalLength, obj.sepalWidth, obj.petalLength, obj.petalWidth]);
        });

        return newArray;
    }
            
    console.log(normalizeDataset(data));

    
    const flowerClassificationIris = async () => {

        const model = tf.sequential();

        //layer 1
        model.add(tf.layers.dense({ units: 8, activation: "relu", inputShape: [4] }));
        model.add(tf.layers.dense({ units: 3, activation: "softmax" }));
        model.compile({
            optimizer: "adam",
            loss: "categoricalCrossentropy",
            metrics: ["accuracy"]
        });


        const xs = tf.tensor2d(normalizeDataset(data), [15, 4]);
        const ys = tf.tensor2d([[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0],
        [0, 1, 0], [0, 1, 0], [0, 1, 0], [0, 1, 0], [0, 1, 0], [0, 0, 1],
        [0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1]], [15, 3]);

        await model.fit(xs, {
            epoch: 100,
            batchSize: xs.length,
            callbacks: {
                onEpochEnd: (epoch, logs) => {
                    console.log(`Epoca: ${epoch + 1} - Perdida: ${logs.loss}`);
                }
            }
        });


        tf.tidy(() => {
            const output = model.predict(tf.tensor2d([[6.7, 3.1, 5.6, 2.1]]));

            output.array().then((num) => {
                console.log(num[0][0]);
            });

        });

    }
    

                



    </script>


</body>
</html>